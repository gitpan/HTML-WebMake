<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head>
 <title>
WebMake: Documentation: Data Sources for the &lt;contents&gt; and &lt;media&gt; Tags
</title>
 <meta name="generator" content="WebMake/1.1" />
 <style>
body {
 background-color: #ffffff; 
 color: #000000; 
 font-size: medium;
 font-family: verdana,lucida,helvetica,sans-serif;
}
// OL,UL,P,BODY,TD,TR,TH,FORM {
 // font-family: verdana,lucida,helvetica,sans-serif;
 // font-size: medium;
 // color: #000000;
}
code, samp, pre
{
 font-family: monospace;
}
H1 { font-size: large; font-family: Garamond,Book Antiqua,Times,serif; }
H2 { font-size: large; font-family: Garamond,Book Antiqua,Times,serif; }
H3 { font-size: medium; font-family: Garamond,Book Antiqua,Times,serif; }
H4 { font-size: small; font-family: Garamond,Book Antiqua,Times,serif; }
H5 { font-size: x-small; font-family: Garamond,Book Antiqua,Times,serif; }
H6 { font-size: xx-small; font-family: Garamond,Book Antiqua,Times,serif; }
A:link {
 font-weight: bold;
 color: #004000;
 text-decoration: underline; 
}
A:visited {
 font-weight: normal;
 color: #008000;
 text-decoration: underline; 
}
A:active {
 font-weight: bold;
 color: #800000;
 text-decoration: underline; 
}
</style>
 
</head>
 <body bgcolor="#ffffff" text="#000000" link="#3300cc" vlink="#660066">
 <font face="lucida,verdana,sans-serif">
 <div align="center">
 <img src="images/WebMakeTitle.png" width="500" height="122" />
</div>
 <table width="100%">
<tr>
<td valign="top">
 <strong><a href="http://webmake.taint.org/">WebMake</a>
 Documentation</strong> (version 1.1)
 
</td>
<td valign="top">
 <div align="right">

 [ <a href="media.html">Back</a> | <a href="for.html">Forward</a> | <a href="index.html">Index</a>
 | <a href="allinone.html">All&nbsp;In&nbsp;One</a> ]
 
</div>
 
</td>
</tr>
</table>
   <table border="0" cellpadding="0" cellspacing="0" width="100%">
 <tr>
<td bgcolor="#aaaaaa">
 <table border="0" cellspacing="4" cellpadding="4" width="100%">
 <tr>
<td bgcolor="#ffffff">
 <table border="0" cellspacing="4" cellpadding="4" width="100%">
 <tr>
<td>
 <h1>Data Sources for the &lt;contents&gt; and &lt;media&gt; Tags</h1><p>
Contents or URLs can be searched for using the <a href="contents.html">&lt;contents&gt;</a>
or <a href="media.html">&lt;media&gt;</a> tags, which allow you to search a data source
(directory, delimiter-separated-values file, database etc.) for a pattern.

</p>
 <p>
Currently two data source protocols are defined, <a href="#file">file:</a> and <a href="#svfile">svfile:</a> .
More will probably follow, especially if other people contribute them, hint
hint ;)

</p>
 <p>
<a href="#file">file:</a> is the default protocol, if none is specified.

</p>
 <a name="Attributes_Supported_By_Datasource_Tags"><h1>Attributes Supported By Datasource Tags</h1></a> <dl>
<dt>
<em>src</em>
</dt>
<dd>
<p>
All datasources require this attribute, which
 specifies a protocol and path, in a URL-style syntax:

</p>
</dd>
 <blockquote>
<p>
<strong>protocol</strong>:<strong>path</strong> 
</p>
</blockquote>
 <dt>
<em>name</em>
</dt>
<dd>
<p>
This attribute is used to specify the pattern of data,
 under this path, which will be converted into content items. The part
 of the data's location which matches this name pattern will become the
 name of the item. Typically, glob patterns, such as "*.txt" or
 ".../*.html" are used.

</p>
</dd>
 <dt>
<em>prefix</em>
</dt>
<dd>
<p>
The items' names can be further modified by specifying
 a <em>prefix</em> and/or <em>suffix</em>; these strings are prepended or
 appended to the raw name to make the name the content is given.

</p>
</dd>
 <dt>
<em>suffix</em>
</dt>
<dd>
<p>
See above.

</p>
</dd>
 <dt>
<em>namesubst</em>
</dt>
<dd>
<p>
a Perl-formatted s// substitution, which is used
 to convert source filenames to content names.

</p>
</dd>
 <dt>
<em>nametr</em>
</dt>
<dd>
<p>
a Perl tr// translation, which is used to convert
 source filenames to content names.

</p>
</dd>
 <dt>
<em>listname</em>
</dt>
<dd>
<p>
a name of a content item. This content item will be
 created, and will contain the names of all content items picked up by
 the <a href="contents.html">&lt;contents&gt;</a> or <a href="media.html">&lt;media&gt;</a> search.

</p>
</dd>
 
</dl>
<p>
In addition, the attributes supported by the <a href="content.html">content tag</a> can
be specified as attributes to <a href="contents.html">&lt;contents&gt;</a>, including
<em>format</em>, <em>up</em>, <em>map</em>, etc.

</p>
 <p>
The content blocks picked up from a <a href="contents.html">&lt;contents&gt;</a> search can
also contain meta-data, such as headlines, visibilty dates, workflow approval
statuses, etc. by including <a href="wmmeta.html">metadata</a>.

</p>
 <a name="file"> <a name="The_file__Protocol"><h1>The file: Protocol</h1></a> </a> <p>
The file: protocol loads content from a directory; each file is made into one
content chunk. The <em>src</em> attribute indicates the source directory, the
<em>name</em> attribute indicates the <a href="globs.html">glob pattern</a> that will pick up the
content items in question. The filename of the file will be used as the
content chunk's name.

</p>
 <blockquote>
<p>
&lt;contents src="stories" name="*.txt" /&gt;

</p>
</blockquote>
 <p>
Note that the files in question are not actually opened until their content
chunks are referenced using ${name} or get_content("name").

</p>
 <p>
Normally only the top level of files inside the <em>src</em> directory are added to
the content set. However, if the <em>name</em> pattern starts with <strong>.../</strong>,
the directory will be searched recursively:

</p>
 <blockquote>
<p>
&lt;contents src="stories" name=".../*.txt" /&gt;

</p>
</blockquote>
 <p>
The resulting content items will contain the full path from that directory
down, i.e. the file <strong>stories/dir1/foo/bar.txt</strong> exists, the example
above would define a content item called
<strong>${dir1/foo/bar.txt}</strong>.

</p>
 <a name="svfile"> <a name="The_svfile__Protocol"><h1>The svfile: Protocol</h1></a> </a> <p>
The svfile: protocol loads content from a delimiter-separated-file; the
<em>src</em> attribute is the name of the file, the <em>name</em> is the <a href="globs.html">glob
pattern</a> used to catch the relevant content items. The <em>namefield</em>
attribute specifies the field number (counting from 1) which the <em>name</em>
pattern is matched against, and the <em>valuefield</em> specifies the number of
the field from which the content chunk is read. The <em>delimiter</em>
attribute specifies the delimiter used to separate values in the file.

</p>
 <blockquote>
<p>
&lt;contents src="svfile:stories.csv" name="*"
 namefield=1 valuefield=2 delimiter="," /&gt;

</p>
</blockquote>
 <a name="Adding_New_Protocols"><h1>Adding New Protocols</h1></a> <p>
New data sources for &lt;contents&gt; and &lt;media&gt; tags are added by
writing an implementation of the <em>DataSourceBase.pm</em> module, in the
<em>HTML::WebMake::DataSources</em> package space (the
<em>lib/HTML/WebMake/DataSources</em> directory of the distribution).

</p>
 <p>
Every data source needs a <em>protocol</em>, an alphanumeric lowercase identifier
to use at the start of the <em>src</em> attribute to indicate that a data source is
of that type.

</p>
 <p>
Each implementation of this module should implement these methods:

</p>
 <dl>
<dt>
<code>new ($parent)</code>
</dt>
<dd>
<p>
instantiate the object, as usual.

</p>
</dd>
 <dt>
<code>add ()</code>
</dt>
<dd>
<p>
add all the items in that data source as content
 chunks. (See below!)

</p>
</dd>
 <dt>
<code>get_location_url ($location)</code>
</dt>
<dd>
<p>
get the location (in URL
 format) of a content chunk loaded by <code>add()</code>.

</p>
</dd>
 <dt>
<code>get_location_contents ($location)</code>
</dt>
<dd>
<p>
get the contents of the
 location. The location, again, is the string provided by <code>add()</code>.

</p>
</dd>
 <dt>
<code>get_location_mod_time ($location)</code>
</dt>
<dd>
<p>
get the current modification
 date of a location for dependency checking. The location, again, is
 in the format of the string provided by <code>add()</code>.

</p>
</dd>
 
</dl>
<p>
Notes:

</p>
 <ul>
<li>
<p>
If you want <code>add()</code> to read the content immediately, call
 <code>$self->{parent}->add_text ($name, $text, $self->{src},
 $modtime)</code>.

</p>
</li>
 <li>
<p>
<code>add()</code> can defer opening and reading content chunks straight away.
 If it calls <code>$self->{parent}->add_location ($name, $location,
 $lastmod)</code>, providing a location string which starts with the data
 source's protocol identifier, the content will not be loaded until
 it is needed, at which point <code>get_location_contents()</code> is called.

</p>
</li>
 <li>
<p>
This location string should contain all the information needed to
 access that content chunk later, even if <code>add()</code> was not been
 called. Consider it as similar to a URL. This is required so that
 <code>get_location_mod_time()</code> (see below) can work.

</p>
</li>
 <li>
<p>
All implementations of <code>add()</code> should call <code>$fixed =
 $self->{parent}->fixname ($name);</code> to modify the name of each
 content chunk appropriately, followed by
 <code>$self->{parent}->add_file_to_list ($fixed);</code> to add the content
 chunk's name to the <em>filelist</em> content item.

</p>
</li>
 <li>
<p>
Data sources that support the &lt;media&gt; tag need to implement
 <code>get_location_url</code>, otherwise an error message will be output.

</p>
</li>
 <li>
<p>
Data sources that support the &lt;contents&gt; tag, and defer
 reading the content until it's required, need to implement
 <code>get_location_contents</code>, which is used to provide content from a
 location set using <code>$self->{parent}->add_location()</code>.

</p>
</li>
 <li>
<p>
Data sources that support the &lt;contents&gt; tag need to implement
 <code>get_location_mod_time</code>. This is used to support dependency
 checking, and should return the modification time (in UNIX
 <code>time()</code> format) of that location. Note that since this is used
 to compare the modification time of a content chunk from the
 previous time webmake was run, and the current modification time,
 this is called before the <strong>real</strong> data source is opened.

</p>
</li>
 
</ul>
<p>

</p>
 
</p>
</td>
</tr>
</table>
 
</td>
</tr>
</table>
 
</td>
</tr>
</table>
 <table width="100%">
<tr>
<td valign="top">
 <strong><a href="http://webmake.taint.org/">WebMake</a>
 Documentation</strong> (version 1.1)
 
</td>
<td valign="top">
 <div align="right">

 [ <a href="media.html">Back</a> | <a href="for.html">Forward</a> | <a href="index.html">Index</a>
 | <a href="allinone.html">All&nbsp;In&nbsp;One</a> ]
 
</div>
 
</td>
</tr>
</table>
 <div align="right">
 <a href="http://webmake.taint.org/"> <img src="images/BuiltWithWebMake.png" border="0" width="88" height="31" /></a> 
</div>
 
</font>
</body>
</html>
